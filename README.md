
[s21_decimal @lucankri 12.02.2023](https://youtu.be/kJU4JOLa8l0)
Смотрел недавно ролик на ютубе по этой теме, в целом довольно много интересных вещей говорит лектор, однако ошибки:
1. 1:58:10 - "При переводе из дец в инт смотрим на `bits[1]` если там что-то есть то вовзращаем ошибку конвертации т.к число очень больше из-за того что у нас один элемент bits и есть int"
С этим не согласен, у нас же есть еще коэфицент из-за которого мы можем заполнить хоть все 3 инта и понизить их с помощью степени до вполне входящего в диапазон целых чисел значения 
### Структура заметки
- [Коротко о Decimal](#коротко-о-decimal)
- [Преобразования](#преобразования)
- [Арифметические операции](#арифметические-операции)
- [Операции сравнения](#операции-сравнения)
- [Другие функции](#операции-сравнения)

### Коротко о Decimal
<details>
<summary>Дебаггер совет</summary>
Хорошая настройка для дебаггера в VSCode (LLDB + CodeLLDB extension):<br>
<code>type format add --format {n_system} '{data_type}'</code><br>
Где <code>n_system</code> система счисления <br>
Двоичная <code>bin</code><br>
Восьмеричная <code>oct</code><br>
Десятичная <code>dec</code><br>
Шестнадцатеричная <code>hex</code><br>
А <code>data_type</code> тип данных, записанный в кавычках одинарных.<br>
Пример:<br>
Смена отображения целочисленных переменных на двоичный вид:<br>
<code>type format add --format bin 'int'</code><br>
</details>

Картинка из экселя которая поможет лучше представить как устроены данные в Decimal
![decimal_scheme](assets/images/decimal_scheme.png)
По этой структуре предлагается написать программу:
```c
typedef struct {
    int bits[4];
} s21_decimal;
```
Посмотрев и поработав с этим проектом я считаю что чуть удобнее будет использовать  `unsigned int`, потому что в нем не резервируется первый бит для знака числа
```c
typedef struct {
    unsigned int bits[4];
} s21_decimal;
```
### Преобразования
##### Из `int`
```c
int s21_from_int_to_decimal(int src, s21_decimal *dst)
```
Если число положительное то кладем прямо так его в `bits[0]`, если отрицательное инвертируем всего биты через `~` и прибавляем `1` тем самым мы избавимся от обратной дополненной записи и положим модуль числа. Еще если число входящее у нас отрицательное нужно выставить единицу в бите знака `s21_decimal`, для этого можно просто присвоить `bits[3]` значение равное единице.
##### Из `float`
```c
int s21_from_float_to_decimal(float src, s21_decimal *dst)
```
##### В `int`
```c
int s21_from_decimal_to_int(s21_decimal src, int *dst)
```
##### В `float`
```c
int s21_from_decimal_to_float(s21_decimal src, float *dst)
```
### Арифметические операции 
##### Сложение
```c
int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)
```
Сложение строится на следующих вещах:
* Валидация входных значений
* Сложение мантисс 
    * Валидация суммы мантисс
* Изменение степени, в зависимости от незначащих нулей, например 0.5000

Последовательность вычислений<br>
Сначала проверка входных значений<br>
Складываем 96 битов одного и 96 битов второго децимала в отдельную структуру где бы все это смогло поместиться<br>
Затем смотрим на степень старушую и приписываем ее в децимал резульатата<br>
После того как мы сложили в отдельную структуру наши мантиссы нам нужно провалидировать ее вычтя дополнительно степени десятки из степени децимала-резульата паралельно деля на степень десятки результат сложения мантисс.<br>
Если наш результат сложения 96+96 мантисс не умещается даже после работы степени по отбрасыванию незначащих десяток, то
нужно пытаться поместить его в 96 битов деля на степень десятки, даже если после этого он не влез (степень превысила 28) то
кидаем ошибку оверфлоу! <br>

##### Вычитание
```c
int s21_sub(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)
```
##### Умножение
```c
int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)
```
##### Деление
```c
int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal *result)
```
### Операции сравнения
##### Меньше (`<`)
```c
int s21_is_less(s21_decimal, s21_decimal)
```
##### Меньше или равно (`<=`)
```c
int s21_is_less_or_equal(s21_decimal, s21_decimal)
```
##### Больше (`>`)
```c
int s21_is_greater(s21_decimal, s21_decimal)
```
##### Больше или равно (`>=`)
```c
int s21_is_greater_or_equal(s21_decimal, s21_decimal)
```
##### Равно (`==`)
```c
int s21_is_equal(s21_decimal, s21_decimal)
```
##### Неравно (`!=`)
```c
int s21_is_not_equal(s21_decimal, s21_decimal)
```
### Другие функции
##### Округление указанного Decimal ближайшего целого числа в сторону отрицательной бесконечности
```c
int s21_floor(s21_decimal value, s21_decimal *result)
```
##### Округление Decimal до ближайшего целого числа
```c
int s21_round(s21_decimal value, s21_decimal *result)
```
##### Отбрасывание дробных цифр, включая конечные нули
```c
int s21_truncate(s21_decimal value, s21_decimal *result)
```
##### Умножение указанного Decimal на -1
```c
int s21_negate(s21_decimal value, s21_decimal *result)
```

От дани:)
Добавлю в понимание еще один логический оператор `^` или по другому `XOR`, кому как удобнее.
Что бы было понятнее, ниже представленно результат работы:

```c
1010 ^ 1100 = 0110

x ^ 1 = !x
x ^ 0 = x
```

Данную операцию намного удобнее использовать для инверсии нужного бита. Например для умножения на `-1`достатачно выполнить `bits[3] ^ (1 << 31)`.
